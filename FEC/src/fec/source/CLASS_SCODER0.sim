External class CLASS_CHECKER2;

CLASS_CHECKER2 class CLASS_SCODER0;
%      -----------------------------------------------------------------
%      ---  COPYRIGHT 1988 by                                        ---
%      ---  Simula a.s.                                              ---
%      ---  Oslo, Norway                                             ---
%      ---                                                           ---
%      ---                 P O R T A B L E     S I M U L A           ---
%      ---              F R O N T - E N D    C O M P I L E R         ---
%      ---      S - C o d e    G e n e r a t o r     P a r t  0.     ---
%      ---                                                           ---
%      --- Selection switches: IZ                                    ---
%      ---                                                           ---
%      ---    'D' Included when dump is wanted                       ---
%      ---    'K' Included always when quick capability wanted       ---
%      ---    'M' Included always when macro capability wanted       ---
%      ---    'P' Included to make compiler use quick procedures     ---
%      ---    'I' Included to make compiler use inserted mnemonics   ---
%      ---    'Z' Included at system generation (for "ZIMULA")       ---
%      ---                                                           ---
%      -----------------------------------------------------------------
begin

%SPORT ON
%REUSE ON
%-Z %RECORD ON

%+I %INSERT $SIMSRC/fec/common.mne
% INSERT $SIMSRC/fec/scoder.mne
%INSERT C:/GitHub/S-Port-Simula/FEC/src/fec/source//scoder.mne

%+I %INSERT $SPORTLIB/rtsinit.mne

      visiblegenerator class codegenerator0;
      begin ref(semchecker) checker;

         short integer maxtagstack; ! Upper bound of tagstack ;

%title ******   Conversion FEC representation => RTS repr.   ******

%      for several of the arrays, Z-selection will set the exact bounds;
%      NOTE: IELSE is "legal" type (to avoid index errors in case of
%            type errors detected in checker)
%            rank(IELSE) = 15 !!!

%+Z      short integer array arr1elttag(1:15);
%+Z      short integer array arr2elttag(1:15);
%+Z      short integer array arr3elttag(1:15);
%-Z      short integer       arr1elttag(  15);
%-Z      short integer       arr2elttag(  15);
%-Z      short integer       arr3elttag(  15);
         ! *** legal: SIMULA types (1-dim, 2-dim, multi-dim) ***;

%+Z      short integer array typetag(1:15);
%-Z      short integer       typetag(  15);
         !*** legal: SIMULA types + IVALU ***;

%+Z      short integer array type_pro_tag(1:15);
%-Z      short integer       type_pro_tag(  15);
         ! *** legal: SIMULA types ***;
         ! Gives tag of the type procedure records defined
           in RTS, which are to be used as prefix for
           a type procedure record generated by FEC ;

%+Z      short integer array e_fnp_ass1(1:15);
%+Z      short integer array e_fnp_ass2(1:15);
%-Z      short integer       e_fnp_ass1(  15);
%-Z      short integer       e_fnp_ass2(  15);
         ! *** legal: SIMULA types ***;
         ! Gives the profile/body tag of the routine Enp<type> ;

%+Z      short integer array e_fnp_acc1(1:15);
%+Z      short integer array e_fnp_acc2(1:15);
%-Z      short integer       e_fnp_acc1(  15);
%-Z      short integer       e_fnp_acc2(  15);
         !*** legal: SIMULA types ***;
         ! Gives the profile/body tag of the routine Enc<type> ;

%+Z      short integer array resulttag(1:15);
%-Z      short integer       resulttag(  15);
         ! *** legal: SIMULA types ***;
         ! Gives tag of the record attribute <type>pro.val ;

%+Z      short integer array quantvarianttag(1:15);
%-Z      short integer       quantvarianttag(  15);
         ! *** legal: SIMULA types + ILABE, PROC, ARRA ;
         ! Gives tag of the attribute in some of the variants
           of the record quant defined in RTS ;

%+Z     short integer array fnp_pro_1(3:6 !ISHOR:ILONG; );
%+Z     short integer array fnp_pro_2(3:6 !ISHOR:ILONG; );
%-Z     short integer       fnp_pro_1(  6);
%-Z     short integer       fnp_pro_2(  6);
         ! *** legal: arithmetic types ***;
         ! Give profile/body tag of the routine FNP_PRO_<type> ;

%+Z      short integer array litpardesvarianttag(1:15);
%-Z      short integer       litpardesvarianttag(  15);
         !*** legal: SIMULA types ***;

%+Z      short integer array fpt_profile(1:15);
%+Z      short integer array fpt_body   (1:15);
%-Z      short integer       fpt_profile(  15);
%-Z      short integer       fpt_body   (  15);
         !*** legal: SIMULA types ***;

%+Z      text array followSL(0:5);
%-Z      text       followSL(  5);
         !*** the most common values of "staticencl" ***;

--%-I %INSERT $SPORTLIB/rtsinit.dcl
%-I %INSERT C:/GitHub/S-Port-Simula/FEC/src/fec/source/RTS-FEC-INTERFACE1.def
% - contains declarations to be visible within the code generator
%title ****** the "assembly stack" with connected procedures ******

%+Z      short integer array asdstack(0:maxasd); !zero never used;
%-Z      character           asdstack(  31    ); !zero never used;
         ! character asd,curasd - declared in visiblegenerator;
         ! asd is top of asdstack - NOTE: asd<>0 => save/restore;

%-I %+PQ     prior
%-I          procedure pushasd;
%-I          ! Called from outbseg, outskipif, outif, expandsave;
%-I          begin
%-I                if curasd >= maxasd then fatal0(246) else
%-I                begin curasd:=curasd+1; asdstack(curasd):=asd end;
%-I          end;

%-I %+PQ     prior
%-I          procedure popasd;
%-I          ! Called from outeseg, outendskip, outendif, expandrestore;
%-I          begin asd:=asdstack(curasd);
%-I                curasd:=curasd-1 end;

%-I %+PQ prior
%-I      procedure checkasdzero;
%-I      ! Called from outeseg, outempty, outendskip, outlabeldef,
%-I        outgoto, outfjumpif, outfdest, setbdest (outbdest), outbjump,
%-I        expandrestore ;
%-I      begin
%-I      if asd <> 0 then asderror(176);
%-I      end;

%-I %+PQ     prior
%-I          procedure checkequalandpop;
%-I          begin if asd <> asdstack(curasd) then asderror(177);
%-I                asd:=asdstack(curasd); curasd:=curasd-1;
%-I          end;
%title ******   The system for handling indices   *******

         !*** NOTE: the index zero must NOT be used ***;
%+Z      short integer array indexused(0:255 !max_index;);
%-Z      character           indexused(  255 !max_index;);

%+Z      short integer curindex;  !last generated index;
%+Z      short integer freeindex; !next available;
%-Z      character     curindex;  !last generated index;
%-Z      character     freeindex; !next available;

%-I %+PQ     prior
%-I          procedure getnewindex;
%-I          begin ! short integer i,j;
%-I              if freeindex<>zero then begin
%-I                 curindex:=freeindex; freeindex:=indexused(freeindex)
%-I              end else
%-I              fatal0(249); !all indices used;
%-I   EXIT: end;

%+PQ     prior
         boolean procedure nonewindex;
         begin
%+Z            short integer i,j;
%-Z            character     i,j;
%+S            Freq(112):=Freq(112)+1;
               j:=10; !leave at least 10 free;
               i:=freeindex;
               while j<>zero do begin
                  if i=zero then begin nonewindex:=true; goto EXIT end;
                  j:=j-1; i:=indexused(i);
               end;
               nonewindex:=false;
               curindex:=freeindex; freeindex:=indexused(freeindex);
   EXIT: end;

%-I      procedure releaseIndex(index); short integer index;
%-I      begin indexused(index):=freeindex; freeindex:=index end;
%title *****   utilities that should NEVER be swapped   *****


%+T      procedure outTagWithIdent(t); short integer t; begin
%+T      	text id; id:-tagID(t);
% +T		    STRC2("SCODER0",sourceline,"outTagWithIdent: " & edit(t) & " = " & id & "   LNG=" & edit(id.length));
%+T     	out2byte(0); out2byte(t);
%+T     	outbyte(id.length);
%+T     	outtext(id);
%+T      end;

%-I %+PQ     prior
%-I          procedure outtag(t); short integer t; begin
%-I %+T         outTagWithIdent(t);
%-IT            out2byte(t);
%-I          end;

%+PQ     prior
         procedure outsint(i); short integer i;
         begin ! Outputs a positive short integer constant;
%+S            Freq(107):=Freq(107)+1;
               if i < 10 then out2byte(i+304)
          else if i < 100 then begin
                  outbyte(2); outbyte(i//10+48); outbyte(rem(i,10)+48);
               end else begin
                  leftsintbuf.putint(i); i:=6;
                  while loadchar(leftsintbuf,i)<>' ' do i:=i-1;
                  i:=6-i;
                  outbyte(i); outtext(leftsintbuf.sub(8-i,i));
               end;
         end;

         procedure outinteger(i); integer i;
         begin ! Outputs a direct integer constant;
%+S            Freq(115):=Freq(115)+1;
               leftintbuf.putint(i); i:=11;
               while loadchar(leftintbuf,i)<>' ' do i:=i-1;
               i:=11-i;
               outbyte(i); outtext(leftintbuf.sub(13-i,i));
         end;
         
%+T      procedure STRC3(m1,line,m2,m3); integer line; text m1,m2,m3;
%+T    	 if traceScode > 1 then begin
%+T			if sysout.image.length < 300 then sysout.image :- blanks(300);
% +T			sysout.outtext("SCODER0.STRC3: sysout.image.length=" & edit(sysout.image.length)); outimage;
% +T			sysout.outtext("SCODER0.STRC3: m1=""" & m1 & """"); outimage;
% +T			sysout.outtext("SCODER0.STRC3: m2=""" & m2 & """"); outimage;
% +T			sysout.outtext("SCODER0.STRC3: " & edit(m3.length) & " m3=""" & m3 & """"); outimage;
%+T			sysout.image.sub(1,8):="SCode: ";
%+T			sysout.image.sub(8,51):=m1 & ".LINE " & edit(line) & ": ";
% +T			sysout.image.sub(32,60):=m2;
%+T			sysout.image.sub(32,sysout.image.length-33):=m2;
%+T			sysout.image.sub(45,sysout.image.length-46):=m3;
%+T			sysout.outimage;
%+T    	 end;
         
%+T      procedure STRC2(m1,line,m2); integer line; text m1,m2;
%+T    	 if traceScode > 1 then begin
%+T			sysout.image.sub(1,8):="SCode: ";
%+T			sysout.image.sub(8,51):=m1 & ".LINE " & edit(line) & ": ";
% +T			sysout.image.sub(32,90):=m2;
%+T			sysout.image.sub(32,sysout.image.length-33):=m2;
%+T			sysout.outimage;
%+T    	 end;
         
%+T      procedure STRC(m); text m;
%+T    	 if traceScode > 1 then begin
%+T          sysout.outtext("SCode: " & m ); 
%+T          sysout.outimage;
%+T    	 end;

%+T      integer procedure GET_TAG(m); text m; begin
%+T         integer hi,lo,tag;
%+T         m.setpos(1);
%+T         hi:=rank(m.getchar); lo:=rank(m.getchar);
%+T         GET_TAG:=hi*256+lo;
%+T    	 end;

%+T      text procedure ED_TTAG(m); text m; begin
%+T         ED_TTAG:-ED_TAG(GET_TAG(m)); 
%+T    	 end;

%+T      text procedure ED_TAG(tag); integer tag; begin
%+T         ED_TAG:-copy(tagID(tag) & "[T:" & edit(tag) & "]"); 
%+T    	 end;

%       TYPE:           notype            : INOTY
%                       integer           : IINTG
%                       short integer     : ISHOR
%                       real              : IREAL
%                       long real         : ILONG
%                       boolean           : IBOOL
%                       character         : ICHAR
%                       label (switch)    : ILABE
%                       text              : ITEXT
%                       ref               : IREF
%                       pointer to record : IPTR
%                       universal         : IELSE
%+T		text procedure ED_TYPE(ttag); integer ttag; begin
% +T			TRC("SCODER0",sourceline,"ED_TYPE  " & edit(ttag) & ", IELSE=" & edit(IELSE));
%+T			ED_TYPE:-copy("TYPE_" & edit(ttag));
%+T			if ttag <= rank(IELSE) then
%+T			switch (0:IELSE) ttag begin
%+T				when INOTY do ED_TYPE:-copy("notype")
%+T				when IINTG do ED_TYPE:-copy("integer")
%+T				when ISHOR do ED_TYPE:-copy("short integer")
%+T				when IREAL do ED_TYPE:-copy("real")
%+T				when ILONG do ED_TYPE:-copy("long real")
%+T				when IBOOL do ED_TYPE:-copy("boolean")
%+T				when ICHAR do ED_TYPE:-copy("character")
%+T				when ILABE do ED_TYPE:-copy("label (switch)")
%+T				when ITEXT do ED_TYPE:-copy("text")
%+T				when IREF  do ED_TYPE:-copy("ref")
%+T				when IPTR do ED_TYPE:-copy("pointer to record")
%+T				when IELSE do ED_TYPE:-copy("universal")
%+T				when NONE  do ED_TYPE:-copy("unknown")
%+T			end;
%+T		end;

      end codegenerator0;

end SCODER0;
